# -*- coding: utf-8 -*-
"""Assignment4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UkeO2hlYiiaRUrXOlzT7-gyNM1JA_66d
"""

import tensorflow as tf
from tensorflow import keras
from keras.datasets import cifar10
from keras.utils import to_categorical
from keras.preprocessing.image import ImageDataGenerator
from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from keras.callbacks import ModelCheckpoint

# Load the CIFAR-10 dataset
(trainX, trainY), (testX, testY) = cifar10.load_data()

# Normalize the images
trainX = trainX.astype('float32') / 255.0
testX = testX.astype('float32') / 255.0

# One-hot encode the labels
trainY = to_categorical(trainY, 10)
testY = to_categorical(testY, 10)

model = Sequential()

# First convolutional layer
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)))
model.add(MaxPooling2D((2, 2)))

# Second convolutional layer
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D((2, 2)))

# Third convolutional layer
model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D((2, 2)))

# Flatten the output
model.add(Flatten())

# Fully connected layer
model.add(Dense(512, activation='relu'))
model.add(Dropout(0.5))

# Output layer
model.add(Dense(10, activation='softmax'))

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Create a directory to save the model checkpoints
import os
checkpoint_dir = 'model_checkpoints'
if not os.path.exists(checkpoint_dir):
    os.makedirs(checkpoint_dir)

# Define the ModelCheckpoint callback
checkpoint_callback = ModelCheckpoint(
    filepath=os.path.join(checkpoint_dir, 'model_epoch_{epoch:02d}.h5'),
    save_weights_only=False,
    save_freq='epoch',
    verbose=1
)

# Data augmentation
datagen = ImageDataGenerator(
    width_shift_range=0.1,
    height_shift_range=0.1,
    horizontal_flip=True
)
datagen.fit(trainX)

# Train the model with the checkpoint callback
history = model.fit(datagen.flow(trainX, trainY, batch_size=64),
                    epochs=25,
                    validation_data=(testX, testY),
                    callbacks=[checkpoint_callback])

# Evaluate the model
test_loss, test_acc = model.evaluate(testX, testY, verbose=2)
print(f"Test accuracy: {test_acc * 100:.2f}%")

import numpy as np
import matplotlib.pyplot as plt

# Predict on test data
predictions = model.predict(testX)

# Plot 4x4 grid of sample test images with their predicted labels
fig, axes = plt.subplots(4, 4, figsize=(10, 10))
axes = axes.ravel()

for i in np.arange(0, 16):
    axes[i].imshow(testX[i].astype('float32'))
    axes[i].set_title(f"Pred: {np.argmax(predictions[i])}")
    axes[i].axis('off')

plt.subplots_adjust(wspace=1, hspace=1)
plt.show()